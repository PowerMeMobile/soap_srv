#!/usr/bin/env escript
%% -*- erlang -*-

-mode(native).

-define(proc_num, 1).
-define(req_num, 1).
-define(batch_size, 2).
-define(req_delay, 100).
-define(start_phone_num, 96597163329).

-define(gv(Key, PropList), proplists:get_value(Key, PropList)).
-define(gv(Key, PropList, Default), proplists:get_value(Key, PropList, Default)).

main(Args) ->
	StartTime = now(),
	process_flag(trap_exit, true),
	io:format("Args: ~p~n", [Args]),
	ok = inets:start(),
	{ok, [Terms]} = file:consult("soap_test.conf"),

	Props = ?gv(props, Terms),
	Tests =
	case Args of
		[Name] -> [T || T <- ?gv(tests, Terms), Name =:= proplists:get_value(name, T)];
		_ -> ?gv(tests, Terms)
	end,

	Recipients =
		list_to_binary(
		  string:join([integer_to_list(R) || R <- lists:seq(?start_phone_num, ?start_phone_num + ?batch_size - 1)], ",")),
	io:format("Recipients: ~p~n", [Recipients]),
	Base64Recipients = base64:encode(Recipients),
	AdditionalProps = [{base64recipients, Base64Recipients}, {recipient, Recipients}],

	Workers =
		[spawn_link(fun() -> do_req(Test, AdditionalProps ++ Props) end) || Test <- Tests],
	io:format("Waiting workers...~n", []),
	wait_workers(Workers, StartTime).

wait_workers([], StartTime) ->
	FinishTime = now(),
	TotalTime = timer:now_diff(FinishTime, StartTime)/1000000,
	TotalMsgs = ?proc_num * ?req_num * ?batch_size,
	AvgThroughput = TotalMsgs/TotalTime,
	io:format(
		"~nSummary:~n"
		"Proc num: ~p~n"
		"Req num per proc: ~p~n"
		"Batch size (recipients per sms req): ~p~n"
		"Total msgs: ~p~n"
		"Total time: ~p~n"
		"Average throughput: ~p~n~n",
			[?proc_num, ?req_num, ?batch_size, TotalMsgs, TotalTime, AvgThroughput]),
	erlang:halt();
wait_workers(Workers, StartTime) ->
	receive
		{'EXIT', Pid, Reason} ->
			io:format("~p terminated with ~p~n", [Pid, Reason]),
			wait_workers(Workers -- [Pid], StartTime);
		Msg ->
			io:format("Sup got unexpected msg: ~p~n. Halt.", [Msg]),
			erlang:halt()
	end.

do_req(Test, Props) ->
	io:format("START ~p !!!!!!!!!!!!!!~n", [?gv(name, Test)]),
	Req = perform_req(?gv(req, Test, <<>>), Props),
	Queries = [{K, perform_req(V, Props)} || {K, V} <- ?gv('query', Test, "")],
	io:format("Body: ~p~n", [Req]),
	io:format("Queries: ~p~n", [Queries]),
	Method = ?gv(http_method, Test),
	Url = ?gv(url, Props) ++ ?gv(soap_method, Test, ""),
	Headers = ?gv(headers, Test, []),
	io:format("Headers: ~p~n", [Headers]),
	ContentType = ?gv('content-type', Test),
	{ok, 200} = perform_request({Method, Url, Headers, ContentType, Queries, Req}),
	io:format("Success~n~n", []).

perform_request({Method, Url, Headers, ContentType, Queries, Body}) ->
    FullUrl = Url ++ query_string(Queries),
	io:format("FullUrl: ~p~n", [FullUrl]),
    Request = case Method of
        get -> {FullUrl, Headers};
		delete -> {FullUrl, Headers};
        _   -> {FullUrl, Headers, ContentType, Body}
    end,
	{ok, {{_, StatusCode, _}, RespHeaders, RespBody}} =
	   	httpc:request(Method, Request, [], []),
	io:format("RespHeaders: ~p~n", [RespHeaders]),
	io:format("RespBody: ~p~n", [RespBody]),
	{ok, StatusCode}.

perform_req(Req, Proplist) ->
	Fun =
	fun
		({Key, Value}, ReqAcc) when is_binary(Value) ->
			binary:replace(ReqAcc, placeholder(Key), Value);
		(_, ReqAcc) -> ReqAcc
	end,
	lists:foldr(Fun, Req, Proplist).

placeholder(Key) when is_atom(Key) ->
	BinKey = atom_to_binary(Key, utf8),
	<<$%,BinKey/binary,$%>>.

query_string([Head|Tail]) ->
    lists:flatten(["?" ++ make_query(Head) | [["&", make_query(Elem)] || Elem <- Tail]]);
query_string([]) -> [].


make_query({Key, Value}) ->
    [url_encode(Key), "=", url_encode(Value)].

url_encode(Value) when is_list(Value) ->
    http_uri:encode(Value);
url_encode(Value) when is_bitstring(Value) ->
    url_encode(binary_to_list(Value));
url_encode(Value) when is_integer(Value) ->
    Value.
